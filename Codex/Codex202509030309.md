**Paste this into Codex:**

Create two new files in `flengyel/timeseries-to-egt` and do not change anything else.

### 1) `src/ts2eg/diagnostics.py`

```python
# src/ts2eg/diagnostics.py
"""
Diagnostics and selection utilities for choosing the number of strategies k.

Public API
----------
- scree_values(X, center=True) -> np.ndarray
- nmf_basis(X, k, iters=200, seed=0, normalize="l2") -> (S, H)
- k_sweep_report(X, ks, builder=None, seed=0, ridge=1e-3, surrogates=0, iaaft_iters=50) -> pd.DataFrame
- plot_k_sweep(summary_df, outdir) -> list[str]
- plot_series_decomposition(v_series=None, V=None, M_Z=None, Q_perp=None, outdir=None) -> list[str]

Notes
-----
- The default `builder` is intentionally simple: it standardizes X, learns an NMF basis,
  uses standardized X as a proxy payoff v, fits A via `estimate_A_from_series`, and finds ESS.
  For real analyses, pass a custom `builder(X, k, ridge, seed)` that constructs payoffs via
  VAR or static-profile games and returns {S, Xk, A, ess_list, r2}.
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Callable, Dict, Iterable, Optional, Tuple, List

import numpy as np
import warnings

try:
    import pandas as pd
except Exception:  # optional dependency
    pd = None  # type: ignore

import matplotlib
matplotlib.use("Agg")  # headless
import matplotlib.pyplot as plt  # noqa: E402

# Try to import ts2eg core; degrade gracefully if missing
try:
    from ts2eg.core import projectors, estimate_A_from_series, find_ESS, nmf_on_X
except Exception as e:  # pragma: no cover
    projectors = None
    estimate_A_from_series = None
    find_ESS = None
    nmf_on_X = None
    warnings.warn(f"ts2eg.core not fully available: {e}")

def _std_rows(X: np.ndarray, eps: float = 1e-12) -> np.ndarray:
    X = np.asarray(X, dtype=float)
    mu = X.mean(axis=1, keepdims=True)
    sd = X.std(axis=1, keepdims=True)
    return (X - mu) / (sd + eps)

def scree_values(X: np.ndarray, center: bool = True) -> np.ndarray:
    """
    Return singular values of X (optionally row-centered), for elbow checks.

    Parameters
    ----------
    X : array (N, T)
    center : bool
        If True, subtract each row's mean before SVD.

    Returns
    -------
    np.ndarray of singular values (descending).
    """
    X = np.asarray(X, dtype=float)
    Xc = X - X.mean(axis=1, keepdims=True) if center else X
    s = np.linalg.svd(Xc, compute_uv=False, full_matrices=False)
    return s

def nmf_basis(X: np.ndarray, k: int, iters: int = 200, seed: int = 0, normalize: str = "l2"
             ) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute a nonnegative factorization X ≈ S @ H.

    Prefers ts2eg.core.nmf_on_X if available; otherwise falls back to sklearn.decomposition.NMF.

    Returns
    -------
    (S, H): S ∈ R^{N×k}, H ∈ R^{k×T}, with columns of H normalized to the simplex.
    """
    X = np.asarray(X, dtype=float)
    N, T = X.shape
    # Shift each row to nonnegative [0,1] range
    X0 = X - X.min(axis=1, keepdims=True)
    X0 /= (X0.max(axis=1, keepdims=True) + 1e-12)

    if nmf_on_X is not None:
        S, H = nmf_on_X(X0, k=k, iters=iters, seed=seed, normalize=normalize)
    else:  # pragma: no cover
        try:
            from sklearn.decomposition import NMF
        except Exception as e:
            raise ImportError("Neither ts2eg.core.nmf_on_X nor sklearn NMF available") from e
        model = NMF(n_components=k, init="nndsvda", random_state=seed, max_iter=iters)
        S = model.fit_transform(X0)
        H = model.components_

    # Normalize H columns onto simplex for interpretability
    colsum = H.sum(axis=0, keepdims=True) + 1e-12
    Hs = H / colsum
    return S, Hs

@dataclass
class KSweepResult:
    k: int
    r2: float
    cond_Xk: float
    n_mixed_nash: int
    n_ess: int

def _default_builder(X: np.ndarray, k: int, ridge: float, seed: int = 0
                    ) -> Dict[str, np.ndarray]:
    """
    Minimal builder used by k_sweep_report if no custom `builder` is supplied.

    Steps:
    - standardize X by row
    - NMF to get (S, H) with H column-normalized
    - set payoff proxy v := standardized X
    - estimate A via estimate_A_from_series(S, X_std, v, k, lambda_=ridge)
    - find ESS via find_ESS(A)

    Returns
    -------
    dict with keys: S, Xk (==H), A, ess_list, r2
    """
    if estimate_A_from_series is None or find_ESS is None:
        raise ImportError("ts2eg.core.estimate_A_from_series/find_ESS not available")
    X_std = _std_rows(X)
    S, H = nmf_basis(X_std, k=k, seed=seed)
    v = X_std
    est = estimate_A_from_series(S, X_std, v, k=k, lambda_=ridge)
    A = est["A"]
    ess_list = [r for r in find_ESS(A, tol=1e-9, max_support=k) if r.get("is_ess", False)]
    r2 = float(est.get("R2", np.nan))
    return {"S": S, "Xk": H, "A": A, "ess_list": ess_list, "r2": r2}

def k_sweep_report(X: np.ndarray,
                   ks: Iterable[int],
                   builder: Optional[Callable[[np.ndarray, int, float, int], Dict[str, np.ndarray]]] = None,
                   seed: int = 0,
                   ridge: float = 1e-3,
                   surrogates: int = 0,
                   iaaft_iters: int = 50
                   ):
    """
    Run a sweep over k and summarize fit and ESS statistics.

    Parameters
    ----------
    X : array (N, T)
    ks : iterable of ints (candidate k)
    builder : function(X, k, ridge, seed) -> dict {S, Xk, A, ess_list, r2}
    ridge : float, ridge penalty used in estimate_A_from_series
    surrogates : int, if >0 compute surrogate ESS rates via ts2eg.extensions.surrogate_ess_frequency

    Returns
    -------
    pandas.DataFrame with columns: k, r2, cond_Xk, n_mixed_nash, n_ess, (optional) ess_rate_surrogate
    """
    if pd is None:
        raise ImportError("pandas required for k_sweep_report")
    if builder is None:
        builder = _default_builder

    rows: List[dict] = []
    for k in ks:
        out = builder(X, k, ridge, seed)
        S, H, A, ess_list, r2 = out["S"], out["Xk"], out["A"], out["ess_list"], out["r2"]

        # conditioning of Xk Xk^T
        XtX = H @ H.T
        svals = np.linalg.svd(XtX, compute_uv=False)
        cond = float(svals.max() / (svals.min() + 1e-15))
        n_mixed = sum(1 for r in ess_list if len(r.get("support", [])) > 1)
        n_ess = len([r for r in ess_list if r.get("is_ess", False)])

        row = {"k": k, "r2": r2, "cond_Xk": cond,
               "n_mixed_nash": n_mixed, "n_ess": n_ess}

        if surrogates > 0:
            try:
                from ts2eg.extensions import surrogate_ess_frequency
                X_std = _std_rows(X)
                summ = surrogate_ess_frequency(S, X_std, X_std, k=k, lambda_=ridge,
                                               num_surrogates=surrogates, iaaft_iters=iaaft_iters,
                                               weights=None, seed=seed)
                row["ess_rate_surrogate"] = float(summ.get("ess_rate", np.nan))
            except Exception as e:  # pragma: no cover
                row["ess_rate_surrogate"] = np.nan
                warnings.warn(f"surrogate_ess_frequency failed for k={k}: {e}")

        rows.append(row)

    df = pd.DataFrame(rows).sort_values("k").reset_index(drop=True)
    return df

def plot_k_sweep(summary_df, outdir: Optional[str] = None) -> List[str]:
    """
    Render selection plots: R^2 vs k, #ESS vs k, cond(XkXt) vs k, and surrogate ESS rate (if present).

    Returns list of saved file paths (if outdir is provided).
    """
    if pd is None:
        raise ImportError("pandas required for plotting")
    df = summary_df
    figs = []

    # R2
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.plot(df["k"], df["r2"], marker="o")
    ax.set_xlabel("k (strategies)")
    ax.set_ylabel("Held-out R^2 (if available)")
    ax.set_title("Replicator fit quality vs k")
    figs.append(("k_r2.png", fig))

    # #ESS and mixed Nash
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(111)
    ax2.plot(df["k"], df["n_ess"], marker="o", label="# ESS")
    ax2.plot(df["k"], df["n_mixed_nash"], marker="s", label="# mixed Nash")
    ax2.set_xlabel("k")
    ax2.set_ylabel("count")
    ax2.set_title("Equilibria vs k")
    ax2.legend()
    figs.append(("k_equilibria.png", fig2))

    # conditioning
    fig3 = plt.figure()
    ax3 = fig3.add_subplot(111)
    ax3.plot(df["k"], df["cond_Xk"], marker="o")
    ax3.set_xlabel("k")
    ax3.set_ylabel("cond(X_k X_k^T)")
    ax3.set_title("Conditioning vs k")
    figs.append(("k_conditioning.png", fig3))

    # surrogate ESS rate if present
    if "ess_rate_surrogate" in df.columns and getattr(df["ess_rate_surrogate"], "notna", lambda: False)().any():
        fig4 = plt.figure()
        ax4 = fig4.add_subplot(111)
        ax4.plot(df["k"], df["ess_rate_surrogate"], marker="o")
        ax4.set_xlabel("k")
        ax4.set_ylabel("ESS rate (IAAFT null)")
        ax4.set_title("Surrogate ESS frequency vs k")
        figs.append(("k_surrogate_rate.png", fig4))

    paths: List[str] = []
    for name, f in figs:
        if outdir:
            import pathlib
            pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)
            p = pathlib.Path(outdir) / name
            f.savefig(p, dpi=150, bbox_inches="tight")
            paths.append(str(p))
        plt.close(f)

    return paths

def plot_series_decomposition(v_series: Optional[np.ndarray] = None,
                              V: Optional[np.ndarray] = None,
                              M_Z: Optional[np.ndarray] = None,
                              Q_perp: Optional[np.ndarray] = None,
                              outdir: Optional[str] = None) -> List[str]:
    """
    Convenience plotter:
    - v_series: (N,T) payoff time series (optional; if None, uses V)
    - V: alias for v_series
    - M_Z: projector to extract zero-sum part over time
    - Q_perp: Helmert contrast block to plot z(t)=Q_perp^T v(t)

    Saves up to three figures: mean payoff, zero-sum components, contrast coordinates.
    """
    if V is None and v_series is None:
        return []
    V = v_series if v_series is not None else V
    N, T = V.shape
    figs = []

    # Mean payoff (common-interest)
    fig1 = plt.figure()
    ax1 = fig1.add_subplot(111)
    mu = V.mean(axis=0)
    ax1.plot(np.arange(T), mu)
    ax1.set_title("Common-interest payoff (mean over players)")
    ax1.set_xlabel("t")
    ax1.set_ylabel(r"$\bar v(t)$")
    figs.append(("mean_payoff.png", fig1))

    # Zero-sum components
    if M_Z is not None:
        fig2 = plt.figure()
        ax2 = fig2.add_subplot(111)
        VZ = M_Z @ V
        ax2.plot(np.arange(T), VZ.T)
        ax2.set_title("Zero-sum payoff components v_Z(t)")
        ax2.set_xlabel("t")
        ax2.set_ylabel("value")
        figs.append(("zero_sum_components.png", fig2))

    # Contrast coordinates
    if Q_perp is not None:
        fig3 = plt.figure()
        ax3 = fig3.add_subplot(111)
        Z = Q_perp.T @ V
        ax3.plot(np.arange(T), Z.T)
        ax3.set_title("Helmert contrast coordinates z(t)=Q_perp^T v(t)")
        ax3.set_xlabel("t")
        ax3.set_ylabel("value")
        figs.append(("contrast_coordinates.png", fig3))

    paths: List[str] = []
    for name, f in figs:
        if outdir:
            import pathlib
            pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)
            p = pathlib.Path(outdir) / name
            f.savefig(p, dpi=150, bbox_inches="tight")
            paths.append(str(p))
        plt.close(f)
    return paths
```

### 2) `examples/select_k_report.py`

```python
# examples/select_k_report.py
"""
Strategy-count (k) selection report for ts2eg.

This script:
1) Simulates an (N,T) multivariate time series X.
2) Runs a sweep over k using diagnostics.k_sweep_report (default builder).
3) Saves a CSV summary and selection plots to ./artifacts/k_selection/.
4) Prints a concise table for quick review.

Usage:
    python -m examples.select_k_report
"""

import os
import numpy as np
import pandas as pd

from ts2eg.diagnostics import scree_values, k_sweep_report, plot_k_sweep

def simulate_X(N=6, T=600, seed=0):
    rng = np.random.default_rng(seed)
    # Simple AR(1) per player with a weak common mode + idiosyncratic noise
    phi = rng.uniform(0.2, 0.8, size=N)
    X = np.zeros((N, T))
    cm = rng.standard_normal(T) * 0.3  # common mode
    eta = rng.standard_normal((N, T))
    for t in range(1, T):
        X[:, t] = phi * X[:, t-1] + eta[:, t]
    X += cm
    return X

def main():
    # 1) Data: user may replace with a real dataset
    X = simulate_X()

    # 2) k sweep (default builder uses proxy payoffs; provide your own builder for production)
    ks = list(range(2, 9))
    df = k_sweep_report(X, ks=ks, builder=None, ridge=1e-3, seed=1, surrogates=0)

    # 3) Save artifacts
    outdir = os.path.join("artifacts", "k_selection")
    os.makedirs(outdir, exist_ok=True)
    df.to_csv(os.path.join(outdir, "k_sweep_summary.csv"), index=False)
    plots = plot_k_sweep(df, outdir=outdir)

    # Scree plot for reference
    s = scree_values(X, center=True)
    import matplotlib.pyplot as plt
    plt.figure()
    plt.plot(np.arange(1, len(s)+1), s, marker="o")
    plt.xlabel("Singular value index")
    plt.ylabel("Singular value")
    plt.title("Scree (centered X)")
    plt.savefig(os.path.join(outdir, "scree.png"), dpi=150, bbox_inches="tight")
    plt.close()

    # 4) Console table
    pd.set_option("display.max_columns", None)
    print("\n== k sweep summary ==\n")
    print(df.to_string(index=False))
    print("\nArtifacts written to:", outdir)
    if plots:
        for p in plots:
            print(" -", p)

if __name__ == "__main__":
    main()
```

### 3) After Codex creates the files, run locally

```bash
# from repo root
python -m venv .venv
# Windows PowerShell:
.\.venv\Scripts\Activate.ps1
# Linux/macOS:
# source .venv/bin/activate

pip install -r requirements.txt
pip install -e .
python -m examples.select_k_report
```

Expected outputs (created in `./artifacts/k_selection/`):

* `k_sweep_summary.csv`
* `k_r2.png`, `k_equilibria.png`, `k_conditioning.png`
* `scree.png`
* (and `k_surrogate_rate.png` if you later enable surrogates in `k_sweep_report(...)`)

**Note:** The default builder uses standardized `X` as a **proxy payoff** to keep it self-contained. For real runs, pass a custom `builder` that computes VAR/static-profile payoffs and returns `{S, Xk, A, ess_list, r2}`; the diagnostics will use those instead.
