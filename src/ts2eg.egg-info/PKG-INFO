Metadata-Version: 2.4
Name: ts2eg
Version: 0.1.0
Summary: Turn multivariate time series into evolutionary games and analyze stability via replicator dynamics.
Author: Your Name
License: MIT
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.24
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"

# gamify-timeseries: From Multivariate Time Series to Evolutionary Games

**TL;DR.** Turn an $N\times T$ multivariate time series into a **normal-form game**, fit an **evolutionary (replicator) model** on a small set of learned strategies, and test for **Evolutionarily Stable Strategies (ESS)**. Evidence of an ESS is treated as evidence of **strategic interaction** in the data.

**Canonical file:** `gamify_timeseries.py`  
**Deprecated shims (historical):** `gamify_timeseries_01.py`, `gameify_timeseries_finance.py`, `gameify_timeseries_finance_biology.py`  
**Optional package:** `ts2eg` (src-layout), exposes the same API for `pip install -e .` users.

---

## Why this exists

Many “inverse EGT” papers start from observed **strategy frequencies**. Real datasets are often **player-level time series** instead. This repo provides a **coordinate pipeline** from player signals to strategies and payoffs:

1. Decompose per-time payoffs into **common-interest** vs **zero-sum** directions (ANOVA/Helmert).
2. Induce payoffs from time series via two choices: static discretized profiles or **information-sharing** gains (VAR-like OLS).
3. Learn a compact **strategy basis** and infer time-varying **mixtures** $x(t)\in\Delta_k$.
4. Fit a **strategy-level payoff operator** $A$ so replicator dynamics apply.
5. Search for **ESS** and quantify significance with **IAAFT surrogates**.

---

## Recommended repository layout

```
.
├── pyproject.toml
├── README.md
├── requirements.txt
├── .github/workflows/ci.yml
├── src/
│   └── ts2eg/
│       ├── __init__.py
│       ├── core.py          # canonical: current gamify_timeseries.py
│       └── extensions.py    # weighted projectors, seasonal VAR, IAAFT harness
├── tests/
│   ├── test_projectors.py
│   ├── test_seasonal_var.py
│   ├── test_extensions_egt.py
│   └── test_package_import.py
├── notebooks/               # .ipynb (not packaged)
│   └── egt_timeseries_demo.ipynb
└── deprecated/
    ├── gamify_timeseries_01.py
    ├── gameify_timeseries_finance.py
    └── gameify_timeseries_finance_biology.py
```

Notes:
- Keep importable code under `src/ts2eg/`. Notebooks and demos live outside `src`.
- If you keep legacy filenames, make them **thin wrappers** that re-export from the package to avoid drift.

---

## Installation

Lightweight dependencies.

```bash
python -m venv .venv
source .venv/bin/activate            # Windows: .venv\Scripts\activate
pip install -r requirements.txt
pip install -e .                     # optional, enables `import ts2eg`
```

CI runs pytest on Python 3.9–3.12 via GitHub Actions.

---

## Quick start

**Option A (standalone file):**
```python
import numpy as np
from gamify_timeseries import (
    static_game_from_series, var_information_sharing_game,
    estimate_A_from_series, find_ESS,
)

N, T = 4, 400
X = np.random.default_rng(0).standard_normal((N, T))
# A) Static profiles -> conditional next-step payoff
resA = static_game_from_series(X, lag=1, bins="tercile", zero_sum_discretization=True)
# B) Information-sharing game via OLS-VAR regression
resB = var_information_sharing_game(X, p=2, ridge=1e-3)
# Strategy basis S (placeholder: rectified PCA; prefer NMF)
U, s, Vt = np.linalg.svd(X - X.mean(axis=1, keepdims=True), full_matrices=False)
k, S = 3, np.abs(U[:, :3])
est = estimate_A_from_series(S, X, X, k=k, lambda_=1e-3)
A = est["A"]
ess = [r for r in find_ESS(A, tol=1e-8, max_support=k) if r["is_ess"]]
print("ESS supports:", [r["support"] for r in ess])
```

**Option B (package):**
```python
import numpy as np
import ts2eg as gm                 # core API
from ts2eg import extensions as ext

N, T = 5, 360
X = np.random.default_rng(1).standard_normal((N, T))
# Seasonal VAR & weights
w = np.ones(N)
res = ext.var_information_sharing_game_seasonal(
    X, p=2, ridge=1e-3, seasonal_period=12, seasonal_multiples=[1,2],
    include_self_always=True, lambda_common=0.0, weights=w
)
# Build S via NMF helper and fit weighted A
X0 = (X - X.min(axis=1, keepdims=True)) / (X.ptp(axis=1, keepdims=True) + 1e-9)
S, H = gm.nmf_on_X(X0, k=3, iters=200, seed=2, normalize="l2")
X_std = (X - X.mean(axis=1, keepdims=True)) / (X.std(axis=1, keepdims=True) + 1e-12)
A = ext.estimate_A_from_series_weighted(S, X_std, X_std, k=3, lambda_=1e-3, weights=w)["A"]
gm.find_ESS(A, tol=1e-8, max_support=3)
```

---

## Pipeline (precise)

**0) Mean/contrast geometry (ANOVA/Helmert).**  
Common-interest projector $M_I=\frac{1}{N}\mathbf 1\mathbf 1^\top$, centering $M_Z=I-M_I$; optional Helmert basis with first column $\mathbf 1/\sqrt N$.

**1) Payoff induction from time series.**
- **Static profiles:** Discretize $M_Z X$ (terciles), map each joint profile to $\mathbb E[X_{t+1}\mid a_t]$; store $M_I$/$M_Z$ components.
- **Information sharing:** For each player $i$, compare MSE(self-only lags) vs MSE(with shared lags); gain = baseline − observed; center across players.

**2) Strategies and mixtures.**  
Learn $S\in\mathbb R^{N\times k}$ (NMF/archetypes recommended). Infer $x(t)\in\Delta_k$ by projecting $X_{\cdot,t}$ onto cone$(S)$ with simplex constraint.

**3) Strategy-level signals.**  
$g(t)=S^\top v_Z(t)$ where $v_Z(t)=M_Z v(t)$.

**4) Replicator-compatible operator.**  
Center in strategy space $M_Z^{(k)}=I-\frac{1}{k}\mathbf 1\mathbf 1^\top$. Fit $A$ via ridge to predict $M_Z^{(k)} g \approx A x$; center rows/columns for replicator invariance.

**5) Equilibria and ESS.**  
Enumerate supports; solve $A_{JJ}x_J=\alpha \mathbf 1$ with $\mathbf 1^\top x_J=1$; check off-support; test stability via the replicator Jacobian on the tangent space.

---

## API (concise)

```python
helmert_Q(N) -> Q
projectors(N) -> (M_I, M_Z)

static_game_from_series(X, lag=1, bins="tercile", zero_sum_discretization=True) -> StaticGameResult
var_information_sharing_game(X, p=1, ridge=0.0, restrict_profiles=None,
                             include_self_always=True, lambda_common=0.0) -> VARSharingGameResult

estimate_A_from_series(S, X, v, k, lambda_=0.0) -> dict(A, Xk, Gk, Gc, R2, Cxx, Cgx)
find_ESS(A, tol=1e-8, max_support=None) -> list[dict]

# package-only add-ons (extensions.py)
weighted_projectors(weights) -> (M_I^(w), M_Z^(w))
var_information_sharing_game_seasonal(..., seasonal_period, seasonal_multiples, weights=None) -> VARSharingGameResult
estimate_A_from_series_weighted(S, X, v, k, lambda_, weights=None) -> dict(...)
iaaft(x, n_iter) / iaaft_matrix(X, n_iter, seed) -> surrogates
surrogate_ess_frequency(S, X, v, k, lambda_, num_surrogates, iaaft_iters, weights=None, seed=0) -> summary
```

---

## Applications & demos (selection)

- **Finance:** capital–labor, factor rotation & governance.  
- **Biology:** ecology/microbiology/cancer per‑capita growth, interaction fields, ESS.  
- **Sociology:** coalitions, protests, diffusion.  
- **Cybersecurity:** detector portfolio governance, deception, orchestration.  
- **SETI (toy):** spectral band allocation nulls.

Provide small CSV templates and synthetic generators in `examples/` where helpful.

---

## Diagnostics & significance

- Fit quality: held‑out $R^2$ of $M_Z^{(k)}g \approx A x$.
- Energy in symmetric vs antisymmetric parts of $A$ to gauge potential vs cyclic structure.
- **Surrogates:** IAAFT per player (preserves marginal + spectrum; breaks coupling). Refit and report Nash/ESS rates.
- Rolling windows: track $A$ and ESS over time.
- Edge case: when $X_t=c_t\mathbf 1$, $v_Z\equiv 0$ and no EGT signal.

---

## Related work (very short)

Orthogonal game decompositions (potential/identical‑interest, zero‑sum/harmonic). Empirical game‑theoretic analysis (EGTA). Inverse EGT from strategy shares. VAR/Granger as information‑sharing payoff. The novelty is the **explicit ANOVA/Helmert transform** at the player level feeding a **strategy‑space** replicator fit end‑to‑end.

---

## Reproducibility

Seed RNGs; keep OLS/ridge deterministic; save $S$, $A$, window parameters; report $k$, $\lambda$, and commit hash.

---

## License

MIT.

---

## Citation

```
@misc{gamify_timeseries_egt,
  title={Gamify Time Series: From Multivariate Signals to Evolutionary Games},
  author={...},
  year={2025},
  note={Version <tag/commit>}
}
```
